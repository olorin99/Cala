struct MaterialData {
  int albedoIndex;
  int normalIndex;
  int metallicRoughnessIndex;
};

struct Material {
  vec3 albedo;
  vec3 normal;
  float metallic;
  float roughness;
};

Material loadMaterial(MaterialData data) {
  Material material;
  if (data.albedoIndex < 0) {
    material.albedo = vec3(1.0);
  } else {
    vec4 albedaRGBA = texture(textureMaps[data.albedoIndex], fsIn.TexCoords);
    if (albedaRGBA.a < 0.5)
    discard;
    material.albedo = albedaRGBA.rgb;
  }

  if (data.normalIndex < 0) {
    material.normal = vec3(0.52, 0.52, 1);
  } else {
    material.normal = texture(textureMaps[data.normalIndex], fsIn.TexCoords).rgb;
  }
  material.normal = normalize(material.normal * 2.0 - 1.0);
  material.normal = normalize(fsIn.TBN * material.normal);

  if (data.metallicRoughnessIndex < 0) {
    material.roughness = 1.0;
    material.metallic = 0.0;
  } else {
    material.metallic = texture(textureMaps[data.metallicRoughnessIndex], fsIn.TexCoords).b;
    material.roughness = texture(textureMaps[data.metallicRoughnessIndex], fsIn.TexCoords).g;
  }
  return material;
}

vec4 evalMaterial(Material material) {

  vec3 viewPos = fsIn.ViewPos;
  vec3 V = normalize(viewPos - fsIn.FragPos);

  vec3 F0 = vec3(0.04);
  F0 = mix(F0, material.albedo, material.metallic);
  vec3 Lo = vec3(0.0);

  uint tileIndex = getTileIndex();

  uint lightCount = lightGrid[tileIndex].count;
  uint lightOffset = lightGrid[tileIndex].offset;

  for (uint i = 0; i < lightCount; i++) {
    Light light = lights[globalLightIndices[lightOffset + i]];
    Lo += pointLight(light, material.normal, viewPos, V, F0, material.albedo, material.roughness, material.metallic);
  }

  vec3 ambient = getAmbient(irradianceIndex, prefilteredIndex, brdfIndex, material.normal, V, F0, material.albedo, material.roughness, material.metallic);
  vec3 colour = (ambient + Lo);

  return vec4(colour, 1.0);
}