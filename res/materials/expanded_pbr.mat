{
    "includes": [],
    "materialData": "struct MaterialData {\n  int albedoIndex;\n  int normalIndex;\n  int metallicRoughnessIndex;\n  float metallness;\n  float roughness;\n};",
    "materialDefinition": "struct Material {\n  vec3 albedo;\n  vec3 normal;\n  float metallic;\n  float roughness;\n};",
    "materialLoad": "CALA_USE_SAMPLED_IMAGE(2D)\n\nMaterial loadMaterial(MaterialData data, InterpolatedValues values) {\n  Material material;\n  if (data.albedoIndex < 0) {\n    material.albedo = vec3(1.0);\n  } else {\n    vec4 albedaRGBA = textureGrad(CALA_COMBINED_SAMPLER2D(nonuniformEXT(data.albedoIndex), globalData.linearRepeatSampler), values.uvGrad.uv, values.uvGrad.ddx, values.uvGrad.ddy);\n\n    material.albedo = albedaRGBA.rgb;\n  }\n\n  if (data.normalIndex < 0) {\n    material.normal = vec3(0.52, 0.52, 1);\n  } else {\n    material.normal = textureGrad(CALA_COMBINED_SAMPLER2D(nonuniformEXT(data.normalIndex), globalData.linearRepeatSampler), values.uvGrad.uv, values.uvGrad.ddx, values.uvGrad.ddy).rgb.rgb;\n  }\n  material.normal = material.normal * 2.0 - 1.0;\n  material.normal = normalize(values.TBN * material.normal);\n\n  if (data.metallicRoughnessIndex < 0) {\n    material.roughness = 1.0;\n    material.metallic = 0.0;\n  } else {\n    material.metallic = textureGrad(CALA_COMBINED_SAMPLER2D(nonuniformEXT(data.metallicRoughnessIndex), globalData.linearRepeatSampler), values.uvGrad.uv, values.uvGrad.ddx, values.uvGrad.ddy).b;\n    material.roughness = textureGrad(CALA_COMBINED_SAMPLER2D(nonuniformEXT(data.metallicRoughnessIndex), globalData.linearRepeatSampler), values.uvGrad.uv, values.uvGrad.ddx, values.uvGrad.ddy).g;\n  }\n  material.metallic += data.metallness;\n  material.roughness += data.roughness;\n  return material;\n}",
    "lit": "vec4 evalMaterial(Material material, InterpolatedValues values) { return vec4(material.albedo, 1.0); }",
    "lit_no_path": "vec4 evalMaterial(Material material, InterpolatedValues values) {\n\n  vec3 viewPos = fsIn.ViewPos;\n  vec3 V = normalize(viewPos - fsIn.FragPos);\n\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, material.albedo, material.metallic);\n  vec3 Lo = vec3(0.0);\n\n  uint tileIndex = getTileIndex();\n\n  uint lightCount = lightGrid[tileIndex].count;\n  uint lightOffset = lightGrid[tileIndex].offset;\n\n  for (uint i = 0; i < lightCount; i++) {\n    Light light = lights[globalLightIndices[lightOffset + i]];\n    Lo += pointLight(light, material.normal, viewPos, V, F0, material.albedo, material.roughness, material.metallic);\n  }\n\n  vec3 ambient = getAmbient(irradianceIndex, prefilteredIndex, brdfIndex, material.normal, V, F0, material.albedo, material.roughness, material.metallic);\n  vec3 colour = (ambient + Lo);\n\n  return vec4(colour, 1.0);\n}",
    "unlit": "vec4 evalMaterial(Material material, InterpolatedValues valuesl) {\n  return vec4(material.albedo, 1.0);\n}",
    "normal": "vec4 evalMaterial(Material material, InterpolatedValues values) {\n  return vec4((material.normal + 1) / 2, 1.0);\n}",
    "roughness": "vec4 evalMaterial(Material material, InterpolatedValues values) {\n  return vec4(material.roughness, 0.0, 0.0, 1.0);\n}",
    "metallic": "vec4 evalMaterial(Material material, InterpolatedValues values) {\n  return vec4(material.metallic, 0.0, 0.0, 1.0);\n}",
    "voxelize": "vec4 evalMaterial(Material material, InterpolatedValues values) {\n\n    CameraData camera = bindlessBuffersCamera[globalData.cameraBufferIndex].camera;\n\n    vec3 viewPos = fsIn.ViewPos;\n    vec3 V = normalize(viewPos - fsIn.FragPos);\n\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, material.albedo, material.metallic);\n    vec3 Lo = vec3(0.0);\n\n    uint lightCount = getTotalLightCount();\n\n    for (uint lightIndex = 0; lightIndex < lightCount; lightIndex++) {\n        Light light = bindlessBuffersLights[globalData.lightBufferIndex].lights[lightIndex];\n        Lo += pointLight(light, material.normal, viewPos, V, F0, material.albedo, material.roughness, material.metallic);\n    }\n\n    vec3 colour = Lo;\n\n    return vec4(colour, 1.0);\n}",
    "depth_state": {
        "test": true,
        "write": true,
        "compareOp": "LESS_EQUAL"
    }
}