
layout (local_size_x = 16, local_size_y = 9, local_size_z = 4) in;

layout (push_constant) uniform ScreenViewInfo {
    mat4 inverseProjection;
    uvec4 tileSizes;
    uvec2 screenSize;
    float near;
    float far;
    int lightGridIndex;
    int lightIndicesIndex;
};

#include "camera.glsl"

#include "global_data.glsl"

struct Cluster {
    vec4 minPoint;
    vec4 maxPoint;
};

layout (set = 1, binding = 1) buffer ClusterSSBO {
    Cluster clusters[];
};

#include "light_data.glsl"

layout (set = 1, binding = 2) buffer GlobalIndex {
    uint globalIndexCount;
};

layout (set = 1, binding = 3) readonly buffer LightCount {
    uint directLightCount;
    uint pointLightCount;
};

shared Light sharedLights[16 * 9 * 4];

bool intersect(Light light, Cluster cluster) {
    vec4 lightPos = (bindlessBuffersCamera[globalData.cameraBufferIndex].camera.view * vec4(light.position, 1.0));

    vec4 closest = max(cluster.minPoint, min(lightPos, cluster.maxPoint));
    vec3 dist = closest.xyz - lightPos.xyz;
    return dot(dist, dist) <= (light.shadowRange * light.shadowRange);
}

void main() {
    if (0 == gl_GlobalInvocationID.x + gl_GlobalInvocationID.y + gl_GlobalInvocationID.z)
        globalIndexCount = 0;

    barrier();

    uint threadCount = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
    uint lightCount = directLightCount + pointLightCount;
    uint tileIndex = gl_LocalInvocationIndex + gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z * gl_WorkGroupID.z;
    uint visibleLightCount = 0;
    const uint maxVisibleLights = 250;
    uint visibleLightIndices[maxVisibleLights];

    uint lightOffset = 0;
    while (lightOffset < lightCount) {
        uint batchSize = min(threadCount, lightCount - lightOffset);
        if (uint(gl_LocalInvocationIndex) < batchSize) {
            uint lightIndex = lightOffset + gl_LocalInvocationIndex;
            sharedLights[gl_LocalInvocationIndex] = bindlessBuffersLights[globalData.lightBufferIndex].lights[lightIndex];
        }
        barrier();

        for (uint light = 0; light < batchSize; light++) {
            if (visibleLightCount < maxVisibleLights && intersect(sharedLights[light], clusters[tileIndex])) {
                visibleLightIndices[visibleLightCount] = lightOffset + light;
                visibleLightCount++;
            }
        }
        lightOffset += batchSize;
    }
    barrier();

    uint offset = atomicAdd(globalIndexCount, visibleLightCount);
    for (uint i = 0; i < visibleLightCount; i++) {
        bindlessBuffersLightIndices[lightIndicesIndex].lightIndices[offset + i] = visibleLightIndices[i];
    }

    bindlessBuffersLightGrid[lightGridIndex].lightGrid[tileIndex].offset = offset;
    bindlessBuffersLightGrid[lightGridIndex].lightGrid[tileIndex].count = visibleLightCount;
}
