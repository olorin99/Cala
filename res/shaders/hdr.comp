
layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

#include "global_data.glsl"

layout (rgba32f, set = 2, binding = 0) uniform readonly image2D hdrMap;
layout (set = 2, binding = 1) uniform writeonly image2D backbuffer;

vec3 uncharted2Tonemap(vec3 x) {
    float A = 0.15;
    float B = 0.50;
    float C = 0.10;
    float D = 0.20;
    float E = 0.02;
    float F = 0.30;
    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;
}


// from https://www.shadertoy.com/view/WdjSW3

vec3 reinhard(vec3 x) {
    return x / (1.0 + x);
}

vec3 reinhard2(vec3 x) {
    const float white = 4.0;
    return (x * (1.0 + x / (white * white))) / (1.0 + x);
}

vec3 aces(vec3 x) {
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return (x * (a * x + b)) / (x * (c * x + d) + e);
}

vec3 unreal(vec3 x) {
    return x / (x + 0.155) * 1.019;
}


// agx from https://www.shadertoy.com/view/cd3XWr

vec3 agxDefaultContrastApprox(vec3 x) {
    vec3 x2 = x * x;
    vec3 x4 = x2 * x2;
    return 15.5     * x4 * x2
        - 40.14     * x4 * x
        + 31.96     * x4
        - 6.868     * x2 * x
        + 0.4298    * x2
        + 0.1191    * x
        - 0.00232;
}

vec3 agx(vec3 x) {
    const mat3 agxMat = mat3(
        0.842479062253094, 0.0423282422610123, 0.0423756549057051,
        0.0784335999999992,  0.878468636469772,  0.0784336,
        0.0792237451477643, 0.0791661274605434, 0.879142973793104);

    const float minEV = -12.47393;
    const float maxEV = 4.26069;

    // input transform
    x = agxMat * x;
    // log2 space encoding
    x = clamp(log2(x), minEV, maxEV);
    x = (x - minEV) / (maxEV - minEV);

    // apply sigmoid functoin approximation
    x = agxDefaultContrastApprox(x);
    return x;
}

vec3 agxEotf(vec3 x) {
    const mat3 agxMatInv = mat3(
        1.19687900512017, -0.0528968517574562, -0.0529716355144438,
        -0.0980208811401368, 1.15190312990417, -0.0980434501171241,
        -0.0990297440797205, -0.0989611768448433, 1.15107367264116);

    //undo input transform
    x = agxMatInv * x;
    return x;
}

vec3 agxLook(vec3 x) {
    const vec3 lw = vec3(0.2126, 0.7152, 0.0722);
    float luma = dot(x, lw);

    vec3 offset = vec3(0.0);
    vec3 slope = vec3(1.0);
    vec3 power = vec3(1.0);
    float sat = 1.0;

    x = pow(x * slope + offset, power);
    return luma + sat * (x - luma);
}

void main() {

    ivec2 globCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(backbuffer);
    if (any(greaterThanEqual(globCoords, outputSize)))
        return;

    vec2 texCoords = globCoords / outputSize;

    vec3 hdr = imageLoad(hdrMap, globCoords).rgb;

//    vec3 result = aces(hdr * globalData.cameraBuffer.camera.exposure);

    vec3 result = agx(hdr);
    result = agxLook(result);
    result = agxEotf(result);

//    vec3 result = vec3(1.0) - exp(-hdr * globalData.cameraBuffer.camera.exposure);

//    vec3 result = uncharted2Tonemap(hdr * globalData.cameraBuffer.camera.exposure);
//    result = result * (1.0 / uncharted2Tonemap(vec3(11.2f)));

//    vec3 result = reinhard(hdr * globalData.cameraBuffer.camera.exposure);
//    vec3 result = reinhard2(hdr * globalData.cameraBuffer.camera.exposure);

//    result = pow(result, vec3(1.0 / globalData.gamma)); //TODO: find how to write to srgb storage images

    imageStore(backbuffer, globCoords, vec4(result, 1.0));

}
