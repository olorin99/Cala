
layout (local_size_x = LOCAL_SIZE_X, local_size_y = LOCAL_SIZE_Y, local_size_z = 1) in;

#include "shaderBridge.h"
#include "bindings.glsl"
#include "visibility_buffer/visibility.glsl"

layout (rg32ui, set = 0, binding = CALA_BINDLESS_STORAGE_IMAGE) uniform readonly uimage2D calaBindlessStorageImages2Dreadonlyrg32ui[];
CALA_USE_STORAGE_IMAGE(2D, writeonly);

layout (push_constant) uniform PushData {
    int visibilityImageIndex;
    int backbufferIndex;
};

vec3 hue2rgb(float hue) {
    hue = fract(hue);
    float r = abs(hue * 6 - 3) - 1;
    float g = 2 - abs(hue * 6 - 2);
    float b = 2 - abs(hue * 6 - 4);
    return clamp(vec3(r, g, b), vec3(0), vec3(1));
}

void main() {

    ivec2 globCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(CALA_GET_STORAGE_IMAGE2D(writeonly, backbufferIndex));
    if (any(greaterThanEqual(globCoords, outputSize)))
        return;

    ivec2 inputSize = imageSize(calaBindlessStorageImages2Dreadonlyrg32ui[visibilityImageIndex]);

    uvec2 data = imageLoad(calaBindlessStorageImages2Dreadonlyrg32ui[visibilityImageIndex], globCoords).rg;
    uint visibility = data.x;
    uint drawID = data.y;

    uint meshletID = getMeshletID(visibility);
    uint primitiveID = getPrimitiveID(visibility);

//    vec3 result = hue2rgb(meshletID * 1.71f);
    vec3 result = hue2rgb(primitiveID * 1.71f);

    imageStore(CALA_GET_STORAGE_IMAGE2D(writeonly, backbufferIndex), globCoords, vec4(result, 1.0));
}
