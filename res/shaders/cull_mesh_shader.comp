
layout (local_size_x = LOCAL_SIZE_X) in;

#include "shaderBridge.h"

struct IndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    uint vertexOffset;
    uint firstInstance;
};

struct MeshTaskCommand {
    uint x;
    uint y;
    uint z;
    uint meshID;
};

layout (set = 2, binding = 0) writeonly buffer DrawCommands {
    MeshTaskCommand commands[];
};

struct MaterialCount {
    uint count;
    uint offset;
};

layout (set = 2, binding = 1) buffer MaterialCounts {
    MaterialCount counts[];
};

bool frustumCheck(vec3 pos, float radius) {
    GPUCamera cullingCamera = globalData.cameraBuffer.camera;

    for (int i = 0; i < 6; i++) {
        if (dot(vec4(pos, 1.0), cullingCamera.frustum.planes[i]) + radius < 0.0) {
            return false;
        }
    }
    return true;
}

void main() {
    uint idx = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x;
    if (idx >= globalData.maxDrawCount)
        return;

    if (idx == 0) {
        for (uint i = 0; i < counts.length(); i++) {
            atomicExchange(counts[i].count, 0);
        }
    }

    barrier();

    GPUMesh mesh = globalData.meshBuffer.meshData[idx];
    if (mesh.enabled == 0)
        return;
    vec3 center = (mesh.max.xyz + mesh.min.xyz) * 0.5;
    center = (globalData.transformsBuffer.transforms[idx] * vec4(center, 1.0)).xyz;
    vec3 halfExtent = (mesh.max.xyz - mesh.min.xyz) * 0.5;

    if (globalData.gpuCulling > 0) {
        if (frustumCheck(center, length(halfExtent))) {
            uint a = atomicAdd(counts[mesh.materialID].count, 1);
            uint offset = counts[mesh.materialID].offset;
            MeshTaskCommand command;
            command.x = uint(ceil(mesh.meshletCount / 32.0));
            command.y = 1;
            command.z = 1;
            command.meshID = idx;
            commands[offset + a] = command;
            atomicAdd(globalData.feedbackBuffer.feedback.drawnMeshes, 1);
        } else {
            atomicAdd(globalData.feedbackBuffer.feedback.culledMeshes, 1);
        }
    } else {
        uint a = atomicAdd(counts[mesh.materialID].count, 1);
        uint offset = counts[mesh.materialID].offset;
        MeshTaskCommand command;
        command.x = 1;
        command.y = 1;
        command.z = 1;
        command.meshID = idx;
        commands[offset + a] = command;
        atomicAdd(globalData.feedbackBuffer.feedback.drawnMeshes, 1);
    }
}
